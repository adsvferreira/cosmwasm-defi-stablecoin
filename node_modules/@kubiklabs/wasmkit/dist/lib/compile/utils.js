"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAndParseTypes = exports.findExecuteMsg = exports.findQueryMsg = exports.readSchemas = void 0;
const fs_1 = require("fs");
const glob_1 = require("glob");
const polar_json_to_ts_1 = require("polar-json-to-ts");
const schemaParser_1 = require("./schemaParser");
const readSchemas = (schemaDir, rawSchemaDir) => {
    // raw files is for CosmWasm 1.1 schema files
    if ((0, fs_1.existsSync)(rawSchemaDir)) {
        const files = (0, glob_1.sync)(rawSchemaDir + '/**/*.json');
        return (files).map(file => JSON.parse((0, fs_1.readFileSync)(file, 'utf-8')));
    }
    else {
        const files = (0, glob_1.sync)(schemaDir + '/**/*.json');
        return (files).map(file => JSON.parse((0, fs_1.readFileSync)(file, 'utf-8')));
    }
};
exports.readSchemas = readSchemas;
const findQueryMsg = (schemas) => {
    return schemas.find((schema) => schema.title === 'QueryMsg');
};
exports.findQueryMsg = findQueryMsg;
const findExecuteMsg = (schemas) => {
    return schemas.find((schema) => schema.title === 'ExecuteMsg' ||
        schema.title === 'ExecuteMsg_for_Empty' || // if cleanse is used, this is never
        schema.title === 'ExecuteMsgForEmpty' ||
        schema.title === 'Cw20ExecuteMsg' ||
        schema.title === 'Snip20ExecuteMsg');
};
exports.findExecuteMsg = findExecuteMsg;
const findAndParseTypes = async (schemas // eslint-disable-line  @typescript-eslint/no-explicit-any
) => {
    const Types = schemas;
    const allTypes = [];
    for (const typ of Types) {
        if (typ.definitions) {
            for (const key of Object.keys(typ.definitions)) {
                // set title
                typ.definitions[key].title = key;
            }
        }
        const result = await (0, polar_json_to_ts_1.compile)(typ, typ.title);
        allTypes.push(result);
    }
    return (0, schemaParser_1.parser)(allTypes);
};
exports.findAndParseTypes = findAndParseTypes;
