"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBalance = exports.sendQuery = exports.executeTransaction = exports.instantiateContract = exports.storeCode = exports.getChainFromAccount = exports.getSigningClient = exports.getClient = void 0;
const arch3_js_1 = require("@archwayhq/arch3.js");
const cosmwasm_stargate_1 = require("@cosmjs/cosmwasm-stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const secretjs_1 = require("secretjs");
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
const types_1 = require("../types");
const constants_1 = require("./constants");
async function getClient(network) {
    const chain = getChainFromAccount(network);
    switch (chain) {
        case types_1.ChainType.Secret: {
            return new secretjs_1.SecretNetworkClient({
                chainId: network.config.chainId,
                url: network.config.endpoint
            });
        }
        case types_1.ChainType.Juno:
        case types_1.ChainType.Osmosis:
        case types_1.ChainType.Terra:
        case types_1.ChainType.Atom:
        case types_1.ChainType.Umee:
        case types_1.ChainType.Nibiru:
        case types_1.ChainType.Neutron: {
            return await cosmwasm_stargate_1.CosmWasmClient.connect(network.config.endpoint);
        }
        case types_1.ChainType.Archway: {
            return await arch3_js_1.ArchwayClient.connect(network.config.endpoint);
        }
        // case ChainType.Injective: {
        // }
        default: {
            console.log("Error from client");
            throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
        }
    }
}
exports.getClient = getClient;
async function getSigningClient(network, account) {
    const chain = getChainFromAccount(network);
    switch (chain) {
        case types_1.ChainType.Secret: {
            const wall = new secretjs_1.Wallet(account.mnemonic);
            return new secretjs_1.SecretNetworkClient({
                url: network.config.endpoint,
                chainId: network.config.chainId,
                wallet: wall,
                walletAddress: account.address
            });
        }
        case types_1.ChainType.Juno: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                hdPaths: [(0, proto_signing_1.makeCosmoshubPath)(0)],
                prefix: "juno"
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
        }
        case types_1.ChainType.Neutron: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                hdPaths: [(0, proto_signing_1.makeCosmoshubPath)(0)],
                prefix: "neutron"
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
        }
        case types_1.ChainType.Atom: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                hdPaths: [(0, proto_signing_1.makeCosmoshubPath)(0)],
                prefix: "cosmos"
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
        }
        case types_1.ChainType.Umee: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                hdPaths: [(0, proto_signing_1.makeCosmoshubPath)(0)],
                prefix: "umee"
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
        }
        case types_1.ChainType.Nibiru: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                hdPaths: [(0, proto_signing_1.makeCosmoshubPath)(0)],
                prefix: "nibi"
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
        }
        case types_1.ChainType.Osmosis: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                hdPaths: [(0, proto_signing_1.makeCosmoshubPath)(0)],
                prefix: "osmo"
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
        }
        case types_1.ChainType.Terra: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                hdPaths: [(0, proto_signing_1.makeCosmoshubPath)(0)],
                prefix: "terra"
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
        }
        case types_1.ChainType.Archway: {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(account.mnemonic, {
                prefix: 'archway'
            });
            return await cosmwasm_stargate_1.SigningCosmWasmClient.connectWithSigner(network.config.endpoint, wallet);
            // TODO: there is issue with cosmjs-types in this version,
            // Types of property 'accountNumber' are incompatible.
            // Type 'Long' is not assignable to type 'bigint'.
            // return await SigningArchwayClient.connectWithSigner(network.config.endpoint, wallet, {
            //   prefix: 'archway'
            // });
        }
        // case ChainType.Injective: {
        // }
        default: {
            console.log("Error from signing client");
            throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
        }
    }
}
exports.getSigningClient = getSigningClient;
function getChainFromAccount(network) {
    if (network.config.accounts.length === 0) { // no account prefix, use neutron
        return types_1.ChainType.Neutron;
    }
    else if (network.config.accounts[0].address.startsWith("juno")) {
        return types_1.ChainType.Juno;
    }
    else if (network.config.accounts[0].address.startsWith("osmo")) {
        return types_1.ChainType.Osmosis;
        // } else if (network.config.accounts[0].address.startsWith("inj")) {
        //   return ChainType.Injective;
    }
    else if (network.config.accounts[0].address.startsWith("archway")) {
        return types_1.ChainType.Archway;
    }
    else if (network.config.accounts[0].address.startsWith("neutron")) {
        return types_1.ChainType.Neutron;
    }
    else if (network.config.accounts[0].address.startsWith("cosmos")) {
        return types_1.ChainType.Atom;
    }
    else if (network.config.accounts[0].address.startsWith("umee")) {
        return types_1.ChainType.Umee;
    }
    else if (network.config.accounts[0].address.startsWith("nibi")) {
        return types_1.ChainType.Nibiru;
    }
    else if (network.config.accounts[0].address.startsWith("terra")) {
        return types_1.ChainType.Terra;
    }
    else if (network.config.accounts[0].address.startsWith("secret")) {
        return types_1.ChainType.Secret;
    }
    else {
        throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
    }
}
exports.getChainFromAccount = getChainFromAccount;
async function storeCode(network, signingClient, sender, contractName, wasmFileContent, customFees, source, builder) {
    const networkName = getChainFromAccount(network);
    switch (networkName) {
        case types_1.ChainType.Secret: {
            const inGasLimit = parseInt(customFees?.gas);
            const inGasPrice = parseFloat(customFees?.amount[0].amount) /
                parseFloat(customFees?.gas);
            signingClient = signingClient;
            const uploadReceipt = await signingClient.tx.compute.storeCode({
                sender: sender,
                wasm_byte_code: wasmFileContent,
                source: source ?? "",
                builder: builder ?? ""
            }, {
                gasLimit: Number.isNaN(inGasLimit) ? undefined : inGasLimit,
                gasPriceInFeeDenom: Number.isNaN(inGasPrice) ? undefined : inGasPrice
            });
            // console.log(uploadReceipt, "sds");
            const res = uploadReceipt?.arrayLog?.find(
            // eslint-disable-next-line  @typescript-eslint/no-explicit-any
            (log) => log.type === "message" && log.key === "code_id");
            if (res === undefined) {
                throw new errors_1.WasmkitError(errors_list_1.ERRORS.GENERAL.STORE_RESPONSE_NOT_RECEIVED, {
                    jsonLog: JSON.stringify(uploadReceipt, null, 2),
                    contractName: contractName
                });
            }
            const codeId = Number(res.value);
            const contractCodeHash = await signingClient.query.compute.codeHashByCodeId({
                code_id: codeId.toString()
            });
            const parsedContractCodeHash = { code_hash: (contractCodeHash.code_hash === undefined) ? "" : contractCodeHash.code_hash };
            return { contractCodeHash: parsedContractCodeHash, codeId: codeId };
        }
        case types_1.ChainType.Juno:
        case types_1.ChainType.Osmosis:
        case types_1.ChainType.Archway:
        case types_1.ChainType.Neutron:
        case types_1.ChainType.Atom:
        case types_1.ChainType.Umee:
        case types_1.ChainType.Nibiru:
        case types_1.ChainType.Terra: {
            const uploadReceipt = await signingClient.upload(sender, wasmFileContent, customFees ?? network.config.fees?.upload ?? constants_1.defaultFees.upload, "uploading");
            const codeId = uploadReceipt.codeId;
            return { codeId: codeId, contractCodeHash: { code_hash: "not_required" } };
        }
        default: {
            throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
        }
    }
}
exports.storeCode = storeCode;
async function instantiateContract(network, signingClient, codeId, sender, contractName, contractCodeHash, initArgs, label, transferAmount, customFees, contractAdmin) {
    const chain = getChainFromAccount(network);
    switch (chain) {
        case types_1.ChainType.Secret: {
            if (contractCodeHash === "mock_hash") {
                throw new errors_1.WasmkitError(errors_list_1.ERRORS.GENERAL.CONTRACT_NOT_DEPLOYED, {
                    param: contractName
                });
            }
            const inGasLimit = parseInt(customFees?.gas);
            const inGasPrice = parseFloat(customFees?.amount[0].amount) /
                parseFloat(customFees?.gas);
            const tx = await signingClient.tx.compute.instantiateContract({
                code_id: codeId,
                sender: sender,
                code_hash: contractCodeHash,
                init_msg: initArgs,
                label: label,
                init_funds: transferAmount
            }, {
                gasLimit: Number.isNaN(inGasLimit) ? undefined : inGasLimit,
                gasPriceInFeeDenom: Number.isNaN(inGasPrice) ? undefined : inGasPrice
            });
            // Find the contract_address in the logs
            const res = tx?.arrayLog?.find(
            // eslint-disable-next-line  @typescript-eslint/no-explicit-any
            (log) => log.type === "message" && log.key === "contract_address");
            if (res === undefined) {
                throw new errors_1.WasmkitError(errors_list_1.ERRORS.GENERAL.INIT_RESPONSE_NOT_RECEIVED, {
                    jsonLog: JSON.stringify(tx, null, 2),
                    contractName: contractName
                });
            }
            return res.value;
        }
        case types_1.ChainType.Juno:
        case types_1.ChainType.Neutron:
        case types_1.ChainType.Atom:
        case types_1.ChainType.Osmosis:
        case types_1.ChainType.Archway:
        case types_1.ChainType.Umee:
        case types_1.ChainType.Nibiru:
        case types_1.ChainType.Terra: {
            const contract = await signingClient.instantiate(sender, codeId, initArgs, label, customFees ?? network.config.fees?.init ?? constants_1.defaultFees.init, {
                funds: transferAmount,
                admin: contractAdmin
            });
            return contract.contractAddress;
        }
        // case ChainType.Injective: {
        // }
        default: {
            throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
        }
    }
}
exports.instantiateContract = instantiateContract;
async function executeTransaction(network, signingClient, sender, contractAddress, contractCodeHash, msgData, transferAmount, customFees, memo) {
    const chain = getChainFromAccount(network);
    switch (chain) {
        case types_1.ChainType.Secret: {
            const inGasLimit = parseInt(customFees?.gas);
            const inGasPrice = parseFloat(customFees?.amount[0].amount) /
                parseFloat(customFees?.gas);
            // eslint-disable-next-line
            return await signingClient.tx.compute.executeContract({
                sender: sender,
                contract_address: contractAddress,
                code_hash: contractCodeHash,
                msg: msgData,
                sent_funds: transferAmount
            }, {
                gasLimit: Number.isNaN(inGasLimit) ? undefined : inGasLimit,
                gasPriceInFeeDenom: Number.isNaN(inGasPrice) ? undefined : inGasPrice,
                memo: memo
            });
        }
        case types_1.ChainType.Juno:
        case types_1.ChainType.Neutron:
        case types_1.ChainType.Atom:
        case types_1.ChainType.Osmosis:
        case types_1.ChainType.Archway:
        case types_1.ChainType.Umee:
        case types_1.ChainType.Nibiru:
        case types_1.ChainType.Terra: {
            const customFeesVal = customFees !== undefined
                ? customFees : network.config.fees?.exec;
            // eslint-disable-next-line
            return await signingClient.execute(sender, contractAddress, msgData, customFeesVal ?? network.config.fees?.exec ?? constants_1.defaultFees.exec, memo === undefined ? "executing" : memo, transferAmount);
        }
        // case ChainType.Injective: {
        // }
        default: {
            throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
        }
    }
}
exports.executeTransaction = executeTransaction;
async function sendQuery(client, network, msgData, contractAddress, contractHash) {
    const chain = getChainFromAccount(network);
    switch (chain) {
        case types_1.ChainType.Secret: {
            return await client.query.compute.queryContract({
                contract_address: contractAddress,
                query: msgData,
                code_hash: contractHash
            });
        }
        case types_1.ChainType.Juno:
        case types_1.ChainType.Neutron:
        case types_1.ChainType.Atom:
        case types_1.ChainType.Osmosis:
        case types_1.ChainType.Archway:
        case types_1.ChainType.Umee:
        case types_1.ChainType.Nibiru:
        case types_1.ChainType.Terra: {
            // eslint-disable-next-line
            return await client.queryContractSmart(contractAddress, msgData);
        }
        // case ChainType.Injective: {
        // }
        default: {
            throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
        }
    }
}
exports.sendQuery = sendQuery;
async function getBalance(client, accountAddress, network) {
    if (client === undefined) {
        throw new errors_1.WasmkitError(errors_list_1.ERRORS.GENERAL.CLIENT_NOT_LOADED);
    }
    const chain = getChainFromAccount(network);
    let balanceDenom = "";
    switch (chain) {
        case types_1.ChainType.Secret: {
            balanceDenom = "uscrt";
            break;
        }
        case types_1.ChainType.Juno: {
            balanceDenom = "ujuno";
            break;
        }
        case types_1.ChainType.Archway: {
            balanceDenom = "aarch";
            break;
        }
        case types_1.ChainType.Neutron: {
            balanceDenom = "untrn";
            break;
        }
        case types_1.ChainType.Atom: {
            balanceDenom = "uatom";
            break;
        }
        case types_1.ChainType.Umee: {
            balanceDenom = "uumee";
            break;
        }
        case types_1.ChainType.Nibiru: {
            balanceDenom = "unibi";
            break;
        }
        case types_1.ChainType.Osmosis: {
            balanceDenom = "uosmo";
            break;
        }
        case types_1.ChainType.Terra: {
            balanceDenom = "uluna";
            break;
        }
    }
    switch (chain) {
        case types_1.ChainType.Secret: {
            const info = await client.query.bank.balance({
                address: accountAddress,
                denom: balanceDenom
            });
            if (info === undefined) {
                throw new errors_1.WasmkitError(errors_list_1.ERRORS.GENERAL.BALANCE_UNDEFINED);
            }
            const infoBalance = info.balance ?? { amount: "0", denom: balanceDenom };
            const normalisedBalance = (infoBalance.amount === undefined ||
                infoBalance.denom === undefined) ? { amount: "0", denom: balanceDenom }
                : { amount: infoBalance.amount, denom: infoBalance.denom };
            return [normalisedBalance];
        }
        case types_1.ChainType.Juno:
        case types_1.ChainType.Archway:
        case types_1.ChainType.Neutron:
        case types_1.ChainType.Atom:
        case types_1.ChainType.Umee:
        case types_1.ChainType.Nibiru:
        case types_1.ChainType.Osmosis:
        case types_1.ChainType.Terra: {
            const info = await client?.getBalance(accountAddress, balanceDenom);
            if (info === undefined) {
                throw new errors_1.WasmkitError(errors_list_1.ERRORS.GENERAL.BALANCE_UNDEFINED);
            }
            return [info];
        }
        // case ChainType.Injective: {
        // }
        default: {
            console.log("Error fetching balance");
            throw new errors_1.WasmkitError(errors_list_1.ERRORS.NETWORK.UNKNOWN_NETWORK, { account: network.config.accounts[0].address });
        }
    }
}
exports.getBalance = getBalance;
// export async function accountInfo(): Promise<any> {
// }
