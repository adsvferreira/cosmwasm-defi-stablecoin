"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialize = void 0;
const chalk_1 = __importDefault(require("chalk"));
const enquirer_1 = __importDefault(require("enquirer"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../lib/constants");
const fetch_1 = require("../util/fetch");
const playground_creation_1 = require("./playground-creation");
function isYarnProject(destination) {
    return fs_extra_1.default.existsSync(path_1.default.join(destination, "yarn.lock"));
}
/**
 * Confirm if user wants to install project dependencies in template directory
 * @param name Selected Dapp template name
 * @param destination location to initialize template
 */
async function confirmDepInstallation(name, destination) {
    let responses;
    const packageManager = isYarnProject(destination) ? "yarn" : "npm";
    try {
        responses = await enquirer_1.default.prompt([
            (0, playground_creation_1.createConfirmationPrompt)("shouldInstall", `Do you want to install template ${name}'s dependencies with ${packageManager} ?`)
        ]);
    }
    catch (e) {
        if (e === "") {
            return false;
        }
        throw e;
    }
    return responses.shouldInstall;
}
/**
 * Checks if the destination directory is non-empty and confirm if the user
 * wants to proceed with the initializing, skips if --force is used.
 * @param destination location to initialize template
 * @param force true if --force flag is used
 */
async function checkDir(destination, force) {
    if (!force) {
        const initDir = fs_extra_1.default.readdirSync(destination);
        let responses;
        if (initDir.length) {
            console.log(`This directory is non-empty...`);
            try {
                responses = await enquirer_1.default.prompt([
                    (0, playground_creation_1.createConfirmationPrompt)("shouldProceedWithNonEmptyDir", `Do you want to proceed with the initialization?`)
                ]);
            }
            catch (e) {
                if (e === "") {
                    return;
                }
                throw e;
            }
            if (!responses.shouldProceedWithNonEmptyDir) {
                console.log("Initialization cancelled");
                process.exit();
            }
        }
    }
}
/**
 * Ensures that the template passed by user exists in kubiklabs/wasmkit-templates,
 * otherwise user can select a template from the existing templates or exit initialization
 * @param basePath path to temporary directory (contains all templates)
 * @param templateName template name passed by user (bare if no template name is passed)
 */
async function checkTemplateExists(projectPath, basePath, templateName) {
    const templatePath = path_1.default.join(basePath);
    if (fs_extra_1.default.existsSync(templatePath)) {
        return [templatePath, templateName];
    }
    else {
        console.log(chalk_1.default.red(`Error occurred: template "${templateName}" does not exist in ${projectPath}`));
        // eslint-disable-next-line  @typescript-eslint/no-explicit-any
        const prompt = new enquirer_1.default.Select({
            name: "Select an option",
            message: "Do you want to pick an existing template or exit?",
            choices: ["Pick an existing template", "exit"]
        });
        const response = await prompt.run();
        if (response === "exit") {
            console.log("Initialization cancelled");
            process.exit();
        }
        else {
            const dApps = fs_extra_1.default
                .readdirSync(basePath, { withFileTypes: true })
                .filter((dirent) => dirent.isDirectory())
                .map((dirent) => dirent.name);
            // eslint-disable-next-line  @typescript-eslint/no-explicit-any
            const dappsPrompt = new enquirer_1.default.Select({
                name: "dapps",
                message: "Pick a template",
                choices: dApps
            });
            const selectedDapp = await dappsPrompt.run();
            return [path_1.default.join(basePath, selectedDapp), selectedDapp];
        }
    }
}
/**
 * returns complete path (eg. "./" => current working directory)
 * @param destination base path
 */
function _normalizeDestination(destination) {
    const workingDirectory = process.cwd();
    if (!destination) {
        return workingDirectory;
    }
    if (path_1.default.isAbsolute(destination))
        return destination;
    return path_1.default.join(workingDirectory, destination);
}
/**
 * Initialize a template from 'kubiklabs/wasmkit-templates' with given name
 * and destination
 * @param force --force flag. If true then contents in destination directory are overwritten
 * @param templateName templateName to initialize from kubiklabs/wasmkit-templates.
 * @param destination destination directory to initialize template to.
 * Defaults to current working directory
 *  - If template name is not passed, the default template is initialized.
 *  - If template name passed is incorrect (template does not exist),
 *    then user is asked to initialize
 *    from one of the existing templates or exit initializing
 *  - If there are conflicting files while copying template,
 *    then user is asked to overwrite each file
 *     or not (if --force is not used).
 *  - If `--force` is used, then conflicting files are overwritten.
 */
async function initialize({ force, projectPath, templateName, destination }) {
    const normalizedDestination = _normalizeDestination(destination);
    fs_extra_1.default.ensureDirSync(normalizedDestination);
    await checkDir(normalizedDestination, force);
    const tempDir = await (0, fetch_1.setUpTempDirectory)();
    const tempDirPath = tempDir.path;
    const tempDirCleanup = tempDir.cleanupCallback;
    console.info(`\nFetching templates from:`, chalk_1.default.gray(projectPath));
    await (0, fetch_1.fetchRepository)(projectPath, tempDirPath);
    if (templateName === undefined) {
        console.log(`Template name not passed: using default template ${chalk_1.default.green(constants_1.DEFAULT_TEMPLATE_PLAYGROUND)}`);
        templateName = constants_1.DEFAULT_TEMPLATE_PLAYGROUND;
    }
    let templatePath;
    [templatePath, templateName] = await checkTemplateExists(projectPath, tempDirPath, templateName);
    await (0, fetch_1.copyTemplatetoDestination)(templatePath, normalizedDestination, true);
    tempDirCleanup(); // clean temporary directory
    console.log(chalk_1.default.greenBright(`\n★ Template ${templateName} initialized in ${normalizedDestination} ★\n`));
    // install dependencies in /templatePath
    const shouldInstallDependencies = await confirmDepInstallation(templateName, normalizedDestination);
    const packageManager = isYarnProject(normalizedDestination) ? "yarn" : "npm";
    let shouldShowInstallationInstructions;
    if (shouldInstallDependencies) {
        const installed = await (0, playground_creation_1.installDependencies)(packageManager, "install", normalizedDestination);
        if (!installed) {
            console.warn(chalk_1.default.red("Failed to install the sample project's dependencies"));
        }
        shouldShowInstallationInstructions = !installed;
    }
    else {
        shouldShowInstallationInstructions = true;
    }
    (0, playground_creation_1.printSuggestedCommands)(packageManager, shouldShowInstallationInstructions);
}
exports.initialize = initialize;
