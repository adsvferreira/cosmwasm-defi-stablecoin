"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typedIdentifier = exports.tsTypeOperator = exports.tsPropertySignature = exports.tsObjectPattern = exports.shorthandProperty = exports.recursiveNamespace = exports.propertySignature = exports.promiseTypeAnnotation = exports.memberExpressionOrIdentifierSnake = exports.memberExpressionOrIdentifier = exports.importStmt = exports.importAminoMsg = exports.identifier = exports.getMessageProperties = exports.getFieldDimensionality = exports.classProperty = exports.classDeclaration = exports.callExpression = exports.bindMethod = exports.arrowFunctionExpression = exports.arrayTypeNDimensions = exports.FieldTypeAsts = void 0;
var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _case = require("case");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
var propertySignature = exports.propertySignature = function propertySignature(name, typeAnnotation) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    type: 'TSPropertySignature',
    key: t.identifier(name),
    typeAnnotation: typeAnnotation,
    optional: optional
  };
};
var identifier = exports.identifier = function identifier(name, typeAnnotation) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var type = t.identifier(name);
  type.typeAnnotation = typeAnnotation;
  type.optional = optional;
  return type;
};
var tsTypeOperator = exports.tsTypeOperator = function tsTypeOperator(typeAnnotation, operator) {
  var obj = t.tsTypeOperator(typeAnnotation);
  obj.operator = operator;
  return obj;
};
var getMessageProperties = exports.getMessageProperties = function getMessageProperties(msg) {
  if (msg.anyOf) return msg.anyOf;
  if (msg.oneOf) return msg.oneOf;
  if (msg.allOf) return msg.allOf;
  return [];
};
var tsPropertySignature = exports.tsPropertySignature = function tsPropertySignature(key, typeAnnotation, optional) {
  var obj = t.tsPropertySignature(key, typeAnnotation);
  obj.optional = optional;
  return obj;
};
var tsObjectPattern = exports.tsObjectPattern = function tsObjectPattern(properties, typeAnnotation) {
  var obj = t.objectPattern(properties);
  obj.typeAnnotation = typeAnnotation;
  return obj;
};
var callExpression = exports.callExpression = function callExpression(callee, _arguments, typeParameters) {
  var callExpr = t.callExpression(callee, _arguments);
  callExpr.typeParameters = typeParameters;
  return callExpr;
};
var bindMethod = exports.bindMethod = function bindMethod(name) {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier('bind')), [t.thisExpression()])));
};
var typedIdentifier = exports.typedIdentifier = function typedIdentifier(name, typeAnnotation) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var type = t.identifier(name);
  type.typeAnnotation = typeAnnotation;
  type.optional = optional;
  return type;
};
var promiseTypeAnnotation = exports.promiseTypeAnnotation = function promiseTypeAnnotation(name) {
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(name))])));
};
var classDeclaration = exports.classDeclaration = function classDeclaration(name, body) {
  var implementsExressions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var superClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var declaration = t.classDeclaration(t.identifier(name), superClass, t.classBody(body));
  if (implementsExressions.length) {
    declaration["implements"] = implementsExressions;
  }
  return declaration;
};
var classProperty = exports.classProperty = function classProperty(name) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isStatic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var prop = t.classProperty(t.identifier(name));
  if (isReadonly) prop.readonly = true;
  if (isStatic) prop["static"] = true;
  if (typeAnnotation) prop.typeAnnotation = typeAnnotation;
  return prop;
};
var arrowFunctionExpression = exports.arrowFunctionExpression = function arrowFunctionExpression(params, body, returnType) {
  var isAsync = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var func = t.arrowFunctionExpression(params, body, isAsync);
  if (returnType) func.returnType = returnType;
  return func;
};
var recursiveNamespace = exports.recursiveNamespace = function recursiveNamespace(names, moduleBlockBody) {
  if (!names || !names.length) return moduleBlockBody;
  var name = names.pop();
  return [t.exportNamedDeclaration(t.tsModuleDeclaration(t.identifier(name), t.tsModuleBlock(recursiveNamespace(names, moduleBlockBody))))];
};
var arrayTypeNDimensions = exports.arrayTypeNDimensions = function arrayTypeNDimensions(body, n) {
  if (!n) return t.tsArrayType(body);
  return t.tsArrayType(arrayTypeNDimensions(body, n - 1));
};
var FieldTypeAsts = exports.FieldTypeAsts = {
  string: function string() {
    return t.tsStringKeyword();
  },
  array: function array(type) {
    return t.tsArrayType(FieldTypeAsts[type]());
  },
  Duration: function Duration() {
    return t.tsTypeReference(t.identifier('Duration'));
  },
  Height: function Height() {
    return t.tsTypeReference(t.identifier('Height'));
  },
  Coin: function Coin() {
    return t.tsTypeReference(t.identifier('Coin'));
  },
  Long: function Long() {
    return t.tsTypeReference(t.identifier('Long'));
  }
};
var shorthandProperty = exports.shorthandProperty = function shorthandProperty(prop) {
  return t.objectProperty(t.identifier(prop), t.identifier(prop), false, true);
};
var importStmt = exports.importStmt = function importStmt(names, path) {
  return t.importDeclaration(names.map(function (name) {
    return t.importSpecifier(t.identifier(name), t.identifier(name));
  }), t.stringLiteral(path));
};
var importAminoMsg = exports.importAminoMsg = function importAminoMsg() {
  return importStmt(['AminoMsg'], '@cosmjs/amino');
};
var getFieldDimensionality = exports.getFieldDimensionality = function getFieldDimensionality(field) {
  var typeName = field.type;
  var isArray = typeName.endsWith('[]');
  var dimensions = 0;
  if (isArray) {
    dimensions = typeName.match(/\[\]/g).length - 1;
    typeName = typeName.replace(/\[\]/g, '');
  }
  return {
    typeName: typeName,
    dimensions: dimensions,
    isArray: isArray
  };
};
var memberExpressionOrIdentifier = exports.memberExpressionOrIdentifier = function memberExpressionOrIdentifier(names) {
  if (names.length === 1) {
    return t.identifier(names[0]);
  }
  if (names.length === 2) {
    var _names = (0, _slicedToArray2["default"])(names, 2),
      b = _names[0],
      a = _names[1];
    return t.memberExpression(t.identifier(a), t.identifier(b));
  }
  var _names2 = (0, _toArray2["default"])(names),
    name = _names2[0],
    rest = _names2.slice(1);
  return t.memberExpression(memberExpressionOrIdentifier(rest), t.identifier(name));
};
var memberExpressionOrIdentifierSnake = exports.memberExpressionOrIdentifierSnake = function memberExpressionOrIdentifierSnake(names) {
  if (names.length === 1) {
    return t.identifier((0, _case.snake)(names[0]));
  }
  if (names.length === 2) {
    var _names3 = (0, _slicedToArray2["default"])(names, 2),
      b = _names3[0],
      a = _names3[1];
    return t.memberExpression(t.identifier((0, _case.snake)(a)), t.identifier((0, _case.snake)(b)));
  }
  var _names4 = (0, _toArray2["default"])(names),
    name = _names4[0],
    rest = _names4.slice(1);
  return t.memberExpression(memberExpressionOrIdentifierSnake(rest), t.identifier((0, _case.snake)(name)));
};